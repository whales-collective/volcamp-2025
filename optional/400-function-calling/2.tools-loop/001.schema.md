# Function Calling Loop

```mermaid
flowchart TD
    Start[<a href="main.go#L17">Program Start</a>]:::start --> Setup[<a href="main.go#L26">Setup OpenAI Client</a>]:::client
    Setup --> DefineTools[<a href="main.go#L32">Define Tools</a>]:::config

    DefineTools --> SpeakTool[<a href="main.go#L33">parler_de Tool</a>]:::tool
    DefineTools --> GreetTool[<a href="main.go#L48">dire_bonjour Tool</a>]:::tool

    SpeakTool --> UserMessage[<a href="main.go#L70">User Input</a>]:::input
    GreetTool --> UserMessage

    UserMessage --> InitMemory[<a href="main.go#L84">Initialize Memory</a>]:::memory
    InitMemory --> MainLoop[<a href="main.go#L101">Main Conversation Loop</a>]:::loop

    MainLoop --> LLMCall[<a href="main.go#L108">Call LLM</a>]:::api
    LLMCall --> CheckReason[<a href="main.go#L116">Check Finish Reason</a>]:::decision

    CheckReason -->|tool_calls| ProcessTools[<a href="main.go#L117">Process Tool Calls</a>]:::process
    CheckReason -->|stop| FinalMessage[<a href="main.go#L201">Display Final Message</a>]:::final
    CheckReason -->|error| ErrorStop[<a href="main.go#L213">Error Stop</a>]:::error

    ProcessTools --> ConvertCalls[<a href="main.go#L128">Convert Tool Calls</a>]:::convert
    ConvertCalls --> AddToMemory[<a href="main.go#L155">Add to Memory</a>]:::memory

    AddToMemory --> ExecLoop[<a href="main.go#L159">Execute Each Tool</a>]:::exec
    ExecLoop --> RouteFunction[<a href="main.go#L226">Route Function</a>]:::route

    RouteFunction -->|parler_de| SpeakHandler[<a href="main.go#L261">speakAbout Handler</a>]:::handler
    RouteFunction -->|dire_bonjour| GreetHandler[<a href="main.go#L281">sayHello Handler</a>]:::handler

    SpeakHandler -->|aligot| Andre[<a href="main.go#L267">André</a>]:::output
    SpeakHandler -->|truffade| Edouard[<a href="main.go#L269">Édouard</a>]:::output
    SpeakHandler -->|other| Vercingetorix[<a href="main.go#L271">Vercingetorix</a>]:::output

    GreetHandler --> Greeting[<a href="main.go#L284">Send Greeting</a>]:::greeting

    Andre --> SaveResult[<a href="main.go#L185">Save Result to Memory</a>]:::memory
    Edouard --> SaveResult
    Vercingetorix --> SaveResult
    Greeting --> SaveResult

    SaveResult --> MoreTools{More Tools?}:::decision
    MoreTools -->|Yes| ExecLoop
    MoreTools -->|No| MainLoop

    FinalMessage --> EndNode[<a href="main.go#L222">Program End</a>]:::final
    ErrorStop --> EndNode

    classDef start fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef client fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    classDef config fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef tool fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
    classDef input fill:#f1f8e9,stroke:#689f38,stroke-width:2px,color:#000
    classDef memory fill:#fce4ec,stroke:#c2185b,stroke-width:2px,color:#000
    classDef loop fill:#e3f2fd,stroke:#1976d2,stroke-width:3px,color:#000
    classDef api fill:#fff8e1,stroke:#f9a825,stroke-width:2px,color:#000
    classDef decision fill:#e8eaf6,stroke:#5e35b1,stroke-width:2px,color:#000
    classDef process fill:#e0f2f1,stroke:#00796b,stroke-width:2px,color:#000
    classDef convert fill:#f9fbe7,stroke:#827717,stroke-width:2px,color:#000
    classDef exec fill:#ffebee,stroke:#c62828,stroke-width:2px,color:#000
    classDef route fill:#e4f7ff,stroke:#0277bd,stroke-width:2px,color:#000
    classDef handler fill:#f3e5ab,stroke:#f57f17,stroke-width:2px,color:#000
    classDef output fill:#dcedc8,stroke:#689f38,stroke-width:2px,color:#000
    classDef greeting fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px,color:#000
    classDef error fill:#ffcdd2,stroke:#d32f2f,stroke-width:3px,color:#000
    classDef final fill:#c5cae9,stroke:#303f9f,stroke-width:3px,color:#000
```

## Simple Overview

**What it does:**
- Connects to a local AI model with conversation loop
- Defines 2 French language tools (same as basic version)
- Processes tool calls **sequentially** (one by one)
- Maintains conversation memory throughout the process
- Continues until AI says it's finished

**Key Difference from Basic Version:**
- **Sequential Processing**: Tools execute one after another (`ParallelToolCalls: false`)
- **Conversation Loop**: Continues conversation until AI decides to stop
- **Memory Management**: Keeps track of entire conversation history
- **Interactive Flow**: AI can request more tools based on previous results

**Tools:**
1. **parler_de** - Talk about a subject
   - Input: subject name
   - Output: Which expert to consult
   - Implementation: [`speakAbout function`](main.go#L261)

2. **dire_bonjour** - Say hello
   - Input: person's name
   - Output: Greeting message
   - Implementation: [`sayHello function`](main.go#L281)

**Main Loop Process:**
1. **Initialize** conversation memory with user message
2. **Loop until stopped:**
   - Send current conversation to LLM
   - Check LLM's response reason:
     - **tool_calls**: Execute requested tools, add results to memory, continue
     - **stop**: Display final message and exit
     - **error**: Handle error and exit
3. **Memory management**: Every message and result stored for context

**Conversation Flow Example:**
```
User: "I want to talk about truffade and say hello to Bob"
→ LLM: "I'll use parler_de tool with 'truffade'"
→ System: Execute tool → "Talk to Édouard"
→ LLM: "Now I'll use dire_bonjour tool with 'Bob'"
→ System: Execute tool → "Hello Bob!"
→ LLM: "I've completed both requests. Talk to Édouard about truffade and said hello to Bob."
→ System: Stop (conversation complete)
```

**Technical Features:**
- **Sequential Execution**: Tools run one at a time for predictable order
- **Conversation Memory**: Full context preserved across multiple tool calls
- **Error Handling**: Graceful handling of function execution errors
- **Type Safety**: Proper message format conversion for OpenAI API
- **Flexible Termination**: AI decides when conversation is complete